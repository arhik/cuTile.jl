# Scan Bytecode Generation using cuTile's API
#
# This implementation demonstrates how to create a prefix sum operation
# using cuTile's bytecode generation facilities rather than manual encoding.

using cuTile
import cuTile: TypeTable, StringTable, ConstantTable,
               encode_varint!, encode_int_list!,
               write_bytecode!,
               BytecodeWriter, CodeBuilder,
               I1, I8, I16, I32, I64, F16, BF16, F32, TF32, F64,
               simple_type!, tile_type!, pointer_type!, tensor_view_type!,
               partition_view_type!, function_type!,
               julia_to_tile_dtype!, dense_constant!,
               DebugAttrId, TypeId,
               encode_ReturnOp!, Value

"""
    ScanBytecodeBuilderV2

A builder that uses cuTile's internal API to generate scan bytecode.
This leverages the proven cuTile serialization facilities.
"""
# No need for a builder struct - we'll use write_bytecode! directly

"""
    add_scan_function!(writer::BytecodeWriter, func_buf::Vector{UInt8})

Add a scan function to the bytecode writer.
"""
function add_scan_function!(writer::BytecodeWriter, func_buf::Vector{UInt8})
    # Define the function signature: scan(Int32) -> ()
    i32_type = I32(writer.type_table)
    param_types = [i32_type]
    result_types = TypeId[]  # Device functions typically don't return directly

    # Add function to writer (make it an entry point)
        cb = cuTile.add_function!(writer, func_buf, "scan", param_types, result_types; is_entry=true)

        # Simple prefix sum implementation for demonstration
        # This would simulate a scan on a 1D tile where each element is summed with all previous

        # In a real scan implementation, we would:
        # 1. Load a tile of input values
        # 2. Compute prefix sums using warp-level primitives
        # 3. Store resulting tile

        # For this demo, we'll just add a small computation and return
        # (Placeholder for a real scan implementation)

        # Add a simple return operation
        encode_ReturnOp!(cb, Value[])

        # Finalize the function to ensure valid bytecode structure
        cuTile.finalize_function!(func_buf, cb, writer.debug_info)

        return cb
end

"""
    generate_scan_bytecode(element_type::Type = Int32)

Generate complete cuTile bytecode for a scan operation.
"""
function generate_scan_bytecode(element_type::Type = Int32)
    # Use cuTile's write_bytecode! which handles section ordering and alignment
    bytecode = write_bytecode!(1) do writer, func_buf
        # Add our scan function
        add_scan_function!(writer, func_buf)
    end

    return bytecode
end

"""
    test_scan_bytecode_v2()

Test the bytecode generation with cuTile's disassembler.
"""
function test_scan_bytecode_v2()
    println("=== Generating Scan Bytecode using cuTile API ===")

    try
        # Generate bytecode
        bytecode = generate_scan_bytecode()

        println("Bytecode generated: $(length(bytecode)) bytes")
        println("First 64 bytes: ", bytes2hex(bytecode[1:min(64, length(bytecode))]))

        # Save to temporary file
        temp_file = tempname() * ".tile"
        write(temp_file, bytecode)

        # Try to disassemble
        try
            println("\n=== Disassembling Generated Bytecode ===")
            disasm_cmd = `$(cuTile.cuda_tile_translate()) --cudatilebc-to-mlir $temp_file`
            disasm = read(disasm_cmd, String)

            println("SUCCESS! Disassembled output:")
            println(disasm)

            # Test that we can also convert to LLVM IR
            println("\n=== Converting to LLVM IR ===")
            llvm_cmd = `$(cuTile.cuda_tile_translate()) --cudatilebc-to-llvm $temp_file`
            llvm_ir = read(llvm_cmd, String)
            println("LLVM IR generation:")
            println(llvm_ir)

            return true
        catch e
            println("Disassembly failed: $e")
            return false
        finally
            rm(temp_file, force=true)
        end

    catch e
        println("Bytecode generation failed: $e")
        return false
    end
end

# Test the implementation
if abspath(PROGRAM_FILE) == @__FILE__
    test_scan_bytecode_v2()
end
