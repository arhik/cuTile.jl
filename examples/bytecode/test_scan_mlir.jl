"""
    Verify Scan Bytecode via MLIR Disassembly

Uses disassemble_tileir to verify generated bytecode produces valid MLIR.
"""

using cuTile
import cuTile: disassemble_tileir, encode_varint!, tile_type!, julia_to_tile_dtype!,
               Value, encode_ReturnOp!, encode_YieldOp!, with_region, new_op!, encode_typeid!,
               IntegerIdentityVal, write_bytecode!, add_function!, finalize_function!,
               TypeId

function test_simple_disassembly()
    println("=" ^ 60)
    println("TEST 1: Verify disassemble_tileir Works")
    println("=" ^ 60)

    bytecode = write_bytecode!(1) do writer, func_buf
        dtype = julia_to_tile_dtype!(writer.type_table, Int32)
        scalar_tile = tile_type!(writer.type_table, dtype, Int[])

        cb = add_function!(writer, func_buf, "entry", [scalar_tile], TypeId[];
                          is_entry=true)
        encode_ReturnOp!(cb, Value[])
        finalize_function!(func_buf, cb, writer.debug_info)
    end

    mlir = disassemble_tileir(bytecode)
    println("MLIR output:")
    for (i, line) in enumerate(split(mlir, "\n")[1:min(12, end)])
        println("  $i: $line")
    end

    has_func = contains(mlir, "cuda_tile.module")
    has_entry = contains(mlir, "@entry")
    has_tile = contains(mlir, "tile")

    if has_func && has_entry && has_tile
        println("\n  PASSED: disassemble_tileir works")
        return true
    else
        println("\n  FAILED: Missing expected content")
        return false
    end
end

function test_scan_disassembly()
    println()
    println("=" ^ 60)
    println("TEST 2: Scan Bytecode with 1D Tile")
    println("=" ^ 60)

    bytecode = write_bytecode!(1) do writer, func_buf
        dtype = julia_to_tile_dtype!(writer.type_table, Int32)
        tile_1d = tile_type!(writer.type_table, dtype, [32])

        cb = add_function!(writer, func_buf, "scan_op", [tile_1d], [tile_1d];
                          is_entry=false)

        encode_varint!(cb.buf, 94)  # ScanOp
        encode_varint!(cb.buf, 1)
        encode_typeid!(cb.buf, tile_1d)
        encode_varint!(cb.buf, 0)
        push!(cb.buf, 0x00)
        encode_varint!(cb.buf, 1)
        push!(cb.buf, 0x01)
        encode_typeid!(cb.buf, dtype)
        encode_varint!(cb.buf, 0)
        encode_varint!(cb.buf, 1)
        encode_varint!(cb.buf, 0)
        encode_varint!(cb.buf, 1)
        body_types = [tile_1d, tile_1d]
        with_region(cb, body_types) do args
            encode_YieldOp!(cb, [args[1]])
        end
        new_op!(cb, 1)
        result = Value(cb.next_value_id - 1)
        encode_ReturnOp!(cb, [result])
        finalize_function!(func_buf, cb, writer.debug_info)
    end

    println("Bytecode: $(length(bytecode)) bytes")

    try
        mlir = disassemble_tileir(bytecode)
        println("\nMLIR output:")
        for (i, line) in enumerate(split(mlir, "\n")[1:min(20, end)])
            println("  $i: $line")
        end

        if contains(mlir, "scan") && contains(mlir, "func")
            println("\n  PASSED: Scan bytecode disassembles")
            return true
        else
            println("\n  FAILED: Missing scan in output")
            return false
        end
    catch e
        println("\n  Note: Disassembly failed (expected for non-entry)")
        println("  Entry requires 0D, scan needs 1D+")
        return false
    end
end

function test_scan_structure()
    println()
    println("=" ^ 60)
    println("TEST 3: Scan Bytecode Structure (0D tiles)")
    println("=" ^ 60)

    bytecode = write_bytecode!(1) do writer, func_buf
        dtype = julia_to_tile_dtype!(writer.type_table, Int32)
        tile = tile_type!(writer.type_table, dtype, Int[])

        cb = add_function!(writer, func_buf, "entry", [tile], TypeId[];
                          is_entry=true)

        encode_varint!(cb.buf, 94)  # ScanOp
        encode_varint!(cb.buf, 1)
        encode_typeid!(cb.buf, tile)
        encode_varint!(cb.buf, 0)
        push!(cb.buf, 0x00)
        encode_varint!(cb.buf, 1)
        push!(cb.buf, 0x01)
        encode_typeid!(cb.buf, dtype)
        encode_varint!(cb.buf, 0)
        encode_varint!(cb.buf, 1)
        encode_varint!(cb.buf, 0)
        encode_varint!(cb.buf, 1)
        body_types = [tile, tile]
        with_region(cb, body_types) do args
            encode_YieldOp!(cb, [args[1]])
        end
        new_op!(cb, 1)
        encode_ReturnOp!(cb, Value[])
        finalize_function!(func_buf, cb, writer.debug_info)
    end

    magic_ok = bytecode[1:8] == b"\x7FTileIR\x00"
    version_ok = bytecode[9] == 13 && bytecode[10] == 1
    has_scan_op = 0x5e in bytecode
    has_int_tag = 0x01 in bytecode
    size_ok = length(bytecode) > 100

    println("Magic header: $(magic_ok ? "OK" : "FAIL")")
    println("Version: $(version_ok ? "13.1" : "FAIL")")
    println("ScanOp(0x5E): $(has_scan_op ? "OK" : "FAIL")")
    println("Identity tag: $(has_int_tag ? "OK" : "FAIL")")
    println("Size > 100: $(size_ok ? "OK" : "FAIL")")

    if magic_ok && version_ok && has_scan_op && has_int_tag && size_ok
        println("\n  PASSED: Bytecode structure valid")
        return true
    else
        println("\n  FAILED: Structure check")
        return false
    end
end

function test_all()
    println()
    println("█" ^ 60)
    println("█  SCAN BYTECODE VERIFICATION")
    println("█" ^ 60)
    println()

    r1 = test_simple_disassembly()
    r2 = test_scan_disassembly()
    r3 = test_scan_structure()

    passed = count([r1, r2, r3])
    println()
    println("=" ^ 60)
    println("RESULTS: $passed/3 tests passed")
    println("=" ^ 60)
end

reload() = include("cuTile/examples/bytecode/test_scan_mlir.jl")

if abspath(PROGRAM_FILE) == @__FILE__
    test_all()
end
