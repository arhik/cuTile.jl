# Test script for scan bytecode generation using cuTile's built-in disassembler
#
# This script validates the bytecode generation for scan operations
# and uses cuTile's built-in disassembler to check if the generated bytecode is valid.

using Test
using cuTile
import cuTile: TypeTable, StringTable, ConstantTable,
               encode_varint!, encode_int_list!,
               disassemble_tileir,
               encode_varint!, encode_varint_list!
import cuTile.Types: SimpleType, CompositeType,
                     I1_TYPE_ID, I32_TYPE_ID,
                     I1, I8, I16, I32, I64, F16, BF16, F32, TF32, F64,
                     SimpleType as ST, CompositeType as CT,
                     julia_to_tile_dtype!, tile_type!, function_type!,
                     pointer_type!, tensor_view_type!, partition_view_type!,
                     dense_constant!

# Include our implementation
include("scan_bytecode.jl")

@testset "Scan Bytecode Generation with Real Disassembler" begin
    @testset "Type System Validation" begin
        # Test that our type system correctly encodes basic types
        type_table = TypeTable()

        # Test simple types
        i32_type = I32(type_table)
        f16_type = F16(type_table)

        @test i32_type.id == I32_TYPE_ID.id
        @test f16_type.id > 0  # Should be a registered type

        # Test tile types
        tile_type = tile_type!(type_table, i32_type, [32, 32])
        @test tile_type.id > 0  # Should be a new type

        # Test function types
        func_type = function_type!(type_table, [tile_type], [tile_type])
        @test func_type.id > 0  # Should be a new type
    end

    @testset "Bytecode Generation and Disassembly" begin
        # Create a generator
        generator = ScanBytecodeGenerator()

        # Test with a small tile size for simpler bytecode
        element_type = Int32
        tile_size = (4, 4)  # Small size for testing

        # Generate sequential scan bytecode
        println("\n=== Generating Sequential Scan Bytecode ===")
        seq_bytecode = generate_prefix_sum_bytecode!(generator, element_type, tile_size)

        # Create full bytecode with tables
        full_seq_bytecode = UInt8[]
        serialize_tables!(generator, full_seq_bytecode)
        append!(full_seq_bytecode, seq_bytecode)

        @test length(full_seq_bytecode) > 0

        # Try to disassemble the bytecode
        try
            println("\n=== Sequential Scan Disassembly ===")
            seq_disasm = disassemble_tileir(full_seq_bytecode)
            println(seq_disasm)
            @test true  # If we got here without error, the bytecode is valid
        catch e
            println("Sequential scan bytecode disassembly failed: $e")
            # Print the raw bytes for debugging
            println("Raw bytes: ", bytes2hex(full_seq_bytecode))
            @test false, "Failed to disassemble sequential scan bytecode"
        end

        # Generate parallel scan bytecode
        println("\n=== Generating Parallel Scan Bytecode ===")
        par_bytecode = generate_parallel_scan_bytecode!(generator, element_type, tile_size)

        # Create full bytecode with tables
        full_par_bytecode = UInt8[]
        serialize_tables!(generator, full_par_bytecode)
        append!(full_par_bytecode, par_bytecode)

        @test length(full_par_bytecode) > 0

        # Try to disassemble the bytecode
        try
            println("\n=== Parallel Scan Disassembly ===")
            par_disasm = disassemble_tileir(full_par_bytecode)
            println(par_disasm)
            @test true  # If we got here without error, the bytecode is valid
        catch e
            println("Parallel scan bytecode disassembly failed: $e")
            # Print the raw bytes for debugging
            println("Raw bytes: ", bytes2hex(full_par_bytecode))
            @test false, "Failed to disassemble parallel scan bytecode"
        end
    end

    @testset "Comparison with Generate Standard Function" begin
        # For comparison, let's generate bytecode for a simple function using cuTile's
        # standard compiler and compare the structure

        # First, create a simple scan function in Julia
        function simple_scan_kernel(input::CuArray{Int32, 2}, output::CuArray{Int32, 2})
            # Simple row-wise scan
            idx = blockIdx().x
            output[idx, 1] = input[idx, 1]
            for i in 2:size(input, 2)
                output[idx, i] = input[idx, i] + output[idx, i-1]
            end
            return nothing
        end

        # Generate bytecode for this function using cuTile's compiler
        try
            @cuprimitive function simple_scan_kernel(input::CuArray{Int32, 2}, output::CuArray{Int32, 2})
                idx = blockDim().x
                output[idx, 1] = input[idx, 1]
                for i in 2:size(input, 2)
                    output[idx, i] = input[idx, i] + output[idx, i-1]
                end
                return nothing
            end

            # Try to get the Tile IR for this function
            ir = code_tiled(simple_scan_kernel, (CuArray{Int32, 2}, CuArray{Int32, 2}))
            println("\n=== Standard Function Tile IR ===")
            println(ir)

            @test contains(ir, "scan") || contains(ir, "add") || contains(ir, "for")
        catch e
            println("Could not generate Tile IR for standard function: $e")
            # This might fail if we don't have the right CUDA setup
            @test_skip "Standard function compilation failed: $e"
        end
    end

    @testset "Manual Bytecode Validation" begin
        # Before disassembly, let's validate the structure of our bytecode manually

        generator = ScanBytecodeGenerator()
        element_type = Float32
        tile_size = (8, 8)

        # Generate sequential bytecode
        seq_bytecode = generate_prefix_sum_bytecode!(generator, element_type, tile_size)

        # Manual validation of structure
        @test length(seq_bytecode) > 0
        @test seq_bytecode[1] == 0x01  # Should start with function tag

        # Check for expected structure
        @test 0x10 in seq_bytecode  # Loop start
        @test 0x11 in seq_bytecode  # Loop end
        @test 0x20 in seq_bytecode  # Load
        @test 0x30 in seq_bytecode  # Add
        @test 0x40 in seq_bytecode  # Store
        @test 0x60 in seq_bytecode  # Return

        # Generate parallel bytecode
        par_bytecode = generate_parallel_scan_bytecode!(generator, element_type, tile_size)

        # Parallel-specific checks
        @test par_bytecode[1] == 0x01  # Function tag
        @test 0x80 in par_bytecode  # Should include warp_prefix_sum

        println("\n=== Manual Validation Passed ===")
        println("Sequential bytecode length: $(length(seq_bytecode)) bytes")
        println("Parallel bytecode length: $(length(par_bytecode)) bytes")

        # Print first few bytes of each for inspection
        println("Sequential first 16 bytes: ", bytes2hex(seq_bytecode[1:min(16, length(seq_bytecode))]))
        println("Parallel first 16 bytes: ", bytes2hex(par_bytecode[1:min(16, length(par_bytecode))]))

        @test true
    end

    @testset "Table Serialization Validation" begin
        generator = ScanBytecodeGenerator()

        # Add some entries to tables
        type_table = generator.type_table
        str_table = generator.string_table
        const_table = generator.constant_table

        # Add a string
        test_str_id = str_table["test_string"]

        # Add a constant
        test_const_id = dense_constant!(const_table, UInt8[1, 2, 3, 4])

        # Serialize tables
        buf = UInt8[]
        serialize_tables!(generator, buf)

        @test length(buf) > 0

        # Try to decode the structure manually
        println("\n=== Table Structure Validation ===")
        pos = 1

        # Type table
        type_table_size = length(type_table)
        @test buf[pos] == type_table_size
        pos += 1
        println("Type table size: $type_table_size")

        # String table
        pos = 1 + 1 + type_table_size  # Skip to string table
        string_table_size = length(str_table)
        @test buf[pos] == string_table_size
        pos += 1
        println("String table size: $string_table_size")

        # Constant table
        pos += sum(length(buf[pos:pos+length(bytes)-1]) for (bytes, _) in items(str_table)) + string_table_size
        constant_table_size = length(const_table)
        @test buf[pos] == constant_table_size
        println("Constant table size: $constant_table_size")

        @test true
    end
end

println("\n=== Test Summary ===")
println("Tests completed. If any disassembly tests failed, it might indicate")
println("that our manual bytecode generation needs adjustment to match cuTile's")
println("expected format. Check the error messages for specific details.")
