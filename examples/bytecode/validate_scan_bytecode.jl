# Validation script for scan bytecode generation
#
# This script validates the correctness of our manually generated
# cuTile bytecode for scan operations and compares it with cuTile's
# built-in expectations.

using cuTile
import cuTile: TypeTable, StringTable, ConstantTable,
               encode_varint!, encode_int_list!,
               write_bytecode!,
               BytecodeWriter, CodeBuilder,
               I1, I8, I16, I32, I64, F16, BF16, F32, TF32, F64,
               simple_type!, tile_type!, pointer_type!, tensor_view_type!,
               partition_view_type!, function_type!,
               julia_to_tile_dtype!, dense_constant!,
               DebugAttrId, TypeId,
               encode_ReturnOp!, Value

"""
    add_scan_function!(writer::BytecodeWriter, func_buf::Vector{UInt8})

Add a scan function with a basic prefix sum implementation.
"""
function add_scan_function!(writer::BytecodeWriter, func_buf::Vector{UInt8})
    # Define the function signature: scan(i32) -> ()
    i32_type = I32(writer.type_table)
    param_types = [i32_type]
    result_types = TypeId[]  # No direct return values

    # Add function to writer (make it an entry point)
    cb = cuTile.add_function!(writer, func_buf, "scan", param_types, result_types; is_entry=true)

    # Simple prefix sum implementation for demonstration
    # In a real implementation, this would:
    # 1. Load a tile of input values
    # 2. Compute prefix sums using warp-level primitives or loop-based approach
    # 3. Store resulting tile

    # For this demo, we'll create a minimal function that meets cuTile's requirements
    # A real scan implementation would include:
    # - Loading tiles of input values
    # - Computing prefix sums across threads
    # - Storing results to output tiles

    # Placeholder for scan implementation - just return for now
    encode_ReturnOp!(cb, Value[])

    # Finalize the function
    cuTile.finalize_function!(func_buf, cb, writer.debug_info)

    return cb
end

"""
    generate_scan_bytecode()

Generate complete cuTile bytecode for a scan operation.
"""
function generate_scan_bytecode()
    # Use cuTile's write_bytecode! which handles section ordering and alignment
    bytecode = write_bytecode!(1) do writer, func_buf
        # Add our scan function
        add_scan_function!(writer, func_buf)
    end

    return bytecode
end

"""
    validate_bytecode(bytecode::Vector{UInt8})

Validate the generated bytecode by attempting to disassemble it.
"""
function validate_bytecode(bytecode::Vector{UInt8})
    # Save to temporary file
    temp_file = tempname() * ".tile"
    write(temp_file, bytecode)

    try
        # Use cuTile's translate tool to disassemble
        disasm_cmd = `$(cuTile.cuda_tile_translate()) --cudatilebc-to-mlir $temp_file`
        disasm = read(disasm_cmd, String)

        println("SUCCESS! Disassembled output:")
        println(disasm)
        return true
    catch e
        println("Disassembly failed: $e")
        return false
    finally
        rm(temp_file, force=true)
    end
end

"""
    main()

Main validation function.
"""
function main()
    println("=== Generating Scan Bytecode ===")

    try
        # Generate bytecode
        bytecode = generate_scan_bytecode()

        println("Bytecode generated: $(length(bytecode)) bytes")
        println("First 64 bytes: ", bytes2hex(bytecode[1:min(64, length(bytecode))]))

        # Validate the bytecode
        success = validate_bytecode(bytecode)

        if success
            println("\n✅ Bytecode validation passed!")
        else
            println("\n❌ Bytecode validation failed!")
            return 1
        end

        return 0

    catch e
        println("❌ Bytecode generation failed: $e")
        return 1
    end
end

# Run the validation
if abspath(PROGRAM_FILE) == @__FILE__
    exit(main())
end
